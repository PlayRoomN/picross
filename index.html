<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Picross 20×20</title>
<style>
  :root{
    --cell:32px;      /* セル基本サイズ（スライダで変更可／初期は自動フィットで上書き） */
    --gap:2px;
    --line:#999;
    --fill:#111;
    --x:#666;
    --sel:#2b8cff;
    --ui-bg:rgba(255,255,255,.9);
    --ui-br:#c9c9c9;
  }
  html,body{height:100%}
  body{margin:0;background:#fafafa;color:#222;
       font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Meiryo,sans-serif}

  /* ヘッダー */
  .topbar{
    position:sticky; top:0; z-index:10;
    background:#fff; border-bottom:1px solid #e5e5e5;
    padding:.5rem .75rem; display:flex; align-items:center; gap:.5rem; flex-wrap:wrap
  }
  .title{font-weight:700; font-size:1rem; margin-right:.25rem}
  .btn{
    padding:.35rem .6rem; border:1px solid var(--ui-br);
    background:#fff; border-radius:8px; cursor:pointer
  }
  .btn:disabled{opacity:.5; cursor:not-allowed}
  .stat{font-size:.9rem; color:#333}
  .seg{width:1px; height:22px; background:#e5e5e5; margin:0 .25rem}
  .range-wrap{display:flex; align-items:center; gap:.5rem;
    padding:.2rem .5rem; border:1px solid var(--ui-br); border-radius:8px; background:#fff}
  input[type="range"]{accent-color:#2b8cff}

  /* メイン2段：上=盤面/ヒント、下=操作 */
  .stage{display:flex; flex-direction:column; gap:.5rem; padding:.5rem}
  .wrap{
    margin:0 auto; width:max-content;
    display:grid; grid-template-columns:auto 1fr;
    grid-template-rows:auto 1fr;
    grid-template-areas:"corner top" "left board";
    gap:6px; user-select:none; touch-action:manipulation; /* ダブルタップズーム抑制 */
  }
  .corner{grid-area:corner; width:calc(var(--cell)*2); height:calc(var(--cell)*2)}
  .top{grid-area:top; display:grid; grid-template-columns:repeat(20,var(--cell)); gap:var(--gap); padding-left:var(--gap)}
  .left{grid-area:left; display:grid; grid-template-rows:repeat(20,var(--cell)); gap:var(--gap); padding-top:var(--gap)}

  .colHint,.rowHint{font-weight:700; font-size:12px; line-height:1.2; color:#222; transition:background-color .12s ease}
  .colHint{display:flex; flex-direction:column; justify-content:flex-end; align-items:center; height:calc(var(--cell)*2 + var(--gap))}
  .rowHint{display:flex; justify-content:flex-end; align-items:center; gap:4px; width:calc(var(--cell)*2 + var(--gap))}
  .done{color:#aaa; font-weight:normal}
  .error{color:#d00 !important}
  .hintError{outline:2px solid #d00; outline-offset:2px; border-radius:4px}
  .hiHint{background:#eaf3ff; border-radius:4px}

  .board{
    grid-area:board;
    display:grid; grid-template-columns:repeat(20,var(--cell)); grid-template-rows:repeat(20,var(--cell));
    gap:var(--gap); background:#ccc; padding:var(--gap); outline:none; transition:transform .2s ease
  }
  .cell{
    width:var(--cell); height:var(--cell); background:#fff; border:1px solid #999;
    display:flex; align-items:center; justify-content:center; font-weight:700; position:relative; overflow:hidden
  }
  .cell.filled{background:var(--fill); color:var(--fill)}
  .cell.xmark{color:var(--x)}
  .cell.selected{box-shadow:0 0 0 2px var(--sel) inset}
  .cell.hiRow::after,.cell.hiCol::after{
    content:""; position:absolute; inset:0; pointer-events:none; background:rgba(43,140,255,.08);
  }
  /* 5の倍数太線＋外周 */
  .cell[data-r="0"], .cell[data-r="5"], .cell[data-r="10"], .cell[data-r="15"]{border-top:2px solid #000}
  .cell[data-c="0"], .cell[data-c="5"], .cell[data-c="10"], .cell[data-c="15"]{border-left:2px solid #000}
  .cell[data-r="19"]{border-bottom:2px solid #000}
  .cell[data-c="19"]{border-right:2px solid #000}

  /* 操作パネル（常設） */
  .control{
    position:sticky; bottom:0; z-index:9; background:var(--ui-bg); backdrop-filter:saturate(1.2) blur(2px);
    border-top:1px solid #e5e5e5; padding:.5rem; display:flex; justify-content:center
  }
  .pad{
    display:flex; gap:14px; align-items:center; flex-wrap:wrap; max-width:960px; width:100%; justify-content:space-between
  }
  .dpad{
    display:grid; grid-template-columns:48px 48px 48px; grid-template-rows:48px 48px 48px; gap:6px
  }
  .dpad .btn{border-radius:12px; font-size:18px}
  .dpad .sp{visibility:hidden}
  .act{
    display:flex; gap:8px; align-items:center; flex-wrap:wrap
  }
  .key{
    width:64px; height:48px; border-radius:12px; font-weight:800; font-size:18px
  }
  .key.fill{background:#111; color:#fff}
  .key.x{color:#444}
  .key.clear{background:#fff}
  .util{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .meter{min-width:90px; text-align:center; font-weight:700}

  /* ダイアログ */
  dialog{border:none; border-radius:12px; box-shadow:0 20px 60px rgba(0,0,0,.25); padding:16px 18px; max-width:min(720px,92vw)}
  dialog::backdrop{background:rgba(0,0,0,.25)}
  .dlg-title{font-weight:700; margin:0 0 .5rem}
  .list{display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:8px; margin:.5rem 0}
  .card{border:1px solid #ddd; border-radius:10px; background:#fff; padding:.5rem}
  .card h4{margin:.2rem 0 .2rem; font-size:.95rem}
  .kbd{display:inline-block; min-width:1.6em; padding:.08rem .45rem; border:1px solid #bbb; border-bottom-width:2px; border-radius:6px; background:#fff; font-weight:700}
  .row{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  .grow{flex:1}

  /* クリア演出 */
  @keyframes boardCelebrate{0%{transform:scale(1)} 15%{transform:scale(1.03)} 100%{transform:scale(1)}
  }
  .board.celebrate{animation:boardCelebrate 800ms ease}
  @keyframes cellPop{0%{transform:scale(.9); filter:brightness(1.1)} 70%{transform:scale(1.02)} 100%{transform:scale(1); filter:brightness(1)}}
  .cell.pop{animation:cellPop 320ms ease forwards}

  /* ===== 画面が狭すぎる場合のオーバーレイ ===== */
  .overlay{
    display:none; position:fixed; z-index:11; inset:0;
    background:rgba(255,255,255,.92);
    align-items:center; justify-content:center; text-align:center;
    padding:2rem; color:#111
  }
  .overlay .box{
    border:1px solid #ddd; border-radius:12px; background:#fff; padding:1rem 1.25rem; max-width:min(520px,92vw)
  }
  .overlay h3{margin:.25rem 0 .5rem; font-size:1.1rem}
  .overlay p{margin:.25rem 0; color:#333}
</style>
</head>
<body>
  <div class="topbar">
    <span class="title">Picross 20×20</span>
    <button id="newBtn" class="btn">新規</button>
    <button id="randBtn" class="btn">ランダム</button>
    <button id="listBtn" class="btn">一覧</button>
    <span class="seg"></span>
    <button id="undoBtn" class="btn" title="取り消し (Ctrl+Z)" disabled>Undo</button>
    <button id="redoBtn" class="btn" title="やり直し (Ctrl+Y)" disabled>Redo</button>
    <span class="seg"></span>
    <div class="range-wrap">
      <label for="cellSlider">サイズ</label>
      <input id="cellSlider" type="range" min="24" max="46" step="2" />
      <span id="cellPx" class="stat">32px</span>
    </div>
    <span class="seg"></span>
    <span id="progress" class="stat">一致率: 0%</span>
    <span class="seg"></span>
    <button id="helpBtn" class="btn">遊び方</button>
  </div>

  <div class="stage">
    <div class="wrap">
      <div class="corner"></div>
      <div class="top" id="top"></div>
      <div class="left" id="left"></div>
      <div class="board" id="board" tabindex="0" aria-label="盤面"></div>
    </div>
  </div>

  <div class="control">
    <div class="pad">
      <div class="dpad">
        <button class="btn sp" aria-hidden="true"></button>
        <button id="upBtn" class="btn" aria-label="上へ">▲</button>
        <button class="btn sp" aria-hidden="true"></button>

        <button id="leftBtn" class="btn" aria-label="左へ">◀</button>
        <button id="okBtn" class="btn" aria-label="黒を置く">●</button>
        <button id="rightBtn" class="btn" aria-label="右へ">▶</button>

        <button class="btn sp" aria-hidden="true"></button>
        <button id="downBtn" class="btn" aria-label="下へ">▼</button>
        <button class="btn sp" aria-hidden="true"></button>
      </div>

      <div class="act">
        <button id="fillBtn" class="btn key fill" title="黒 (Space/Enter)">●</button>
        <button id="xBtn" class="btn key x" title="× (X)">×</button>
        <button id="clearBtn" class="btn key clear" title="解除 (C)">□</button>
      </div>

      <div class="util">
        <div class="meter" id="meter">0,0</div>
        <button id="checkBtn" class="btn">チェック</button>
        <button id="resetBtn" class="btn">リセット</button>
      </div>
    </div>
  </div>

  <!-- 画面が狭すぎる場合のオーバーレイ -->
  <div id="tooSmall" class="overlay" role="alert" aria-live="assertive" aria-atomic="true">
    <div class="box">
      <h3>プレイ不可（画面が狭すぎます）</h3>
      <p>初期表示で「盤面＋行列ヒント」が収まりませんでした。</p>
      <p>画面サイズを広げるか、別の端末／向きをお試しください。</p>
    </div>
  </div>

  <!-- 一覧ダイアログ -->
  <dialog id="listDlg" aria-labelledby="listTitle">
    <p id="listTitle" class="dlg-title">パズル一覧（20×20）</p>
    <div class="list" id="listWrap"></div>
    <div class="row" style="justify-content:flex-end; margin-top:.5rem">
      <button id="listClose" class="btn">閉じる</button>
    </div>
  </dialog>

  <!-- 遊び方 -->
  <dialog id="helpDlg" aria-labelledby="helpTitle">
    <p id="helpTitle" class="dlg-title">遊び方（共通UI）</p>
    <ul>
      <li>目的：行・列ヒント（黒の連続数）に従って塗り、<b>完全一致</b>でクリア。</li>
      <li>D-Pad：1押し=1マス移動（長押しで加速）。中央の●は「黒を置く」。</li>
      <li>操作ボタン：<span class="kbd">●</span> 黒、<span class="kbd">×</span> バツ、<span class="kbd">□</span> 解除。</li>
      <li>キーボード：矢印=移動／<span class="kbd">Space</span>/<span class="kbd">Enter</span>=黒／<span class="kbd">X</span>=×／<span class="kbd">C</span>=解除。</li>
      <li>エラー：ヒントが矛盾すると赤。達成は灰色。</li>
    </ul>
    <div class="row" style="justify-content:flex-end; margin-top:.5rem">
      <button id="helpClose" class="btn">閉じる</button>
    </div>
  </dialog>

<script>
/* ==================== 基本設定 ==================== */
const ROWS=20, COLS=20;
const LS_CELL_KEY="picross-20x20-cellpx";
const LS_LAST_ID="picross-20x20-lastid";
const REPEAT_DELAY=280;   // 長押し開始(ms)
const REPEAT_STEP=45;     // 長押し間隔(ms)

/* ===== 自動フィット用の定数 ===== */
const MIN_CELL = 24;
const MAX_CELL = 46;
const STEP_CELL = 2;
const SAFETY_W = 8;  // 幅の安全マージン（スクロールバー等の誤差対策）
const SAFETY_H = 8;  // 高さの安全マージン

/* ==================== パズル外部読込 ==================== */
let PUZZLES = [];
async function loadPuzzles(){
  const res = await fetch('puzzles.json', { cache: 'no-store' });
  if(!res.ok){ throw new Error('puzzles.json の読み込みに失敗しました'); }
  PUZZLES = await res.json();
  if(!Array.isArray(PUZZLES) || PUZZLES.length===0){ throw new Error('puzzles.json が空です'); }
}

/* ==================== 便利関数 ==================== */
const byId = (id)=>document.getElementById(id);
function runs(arr){let out=[],cnt=0;for(const v of arr){if(v)cnt++;else if(cnt){out.push(cnt);cnt=0}}if(cnt)out.push(cnt);return out.length?out:[0];}
function sum(a){return a.reduce((x,y)=>x+y,0)}
function maxv(a){return a.length?Math.max(...a):0}
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v))}
function strToGrid(lines){ // 20行の'.#'を0/1へ
  return lines.slice(0,ROWS).map(row=> row.slice(0,COLS).split("").map(ch=> ch==="#"?1:0));
}

/* ==================== DOM取得 ==================== */
const topEl=byId('top'), leftEl=byId('left'), boardEl=byId('board');
const progressEl=byId('progress'), meterEl=byId('meter');
const undoBtn=byId('undoBtn'), redoBtn=byId('redoBtn'), resetBtn=byId('resetBtn');
const checkBtn=byId('checkBtn');
const newBtn=byId('newBtn'), randBtn=byId('randBtn'), listBtn=byId('listBtn');
const helpBtn=byId('helpBtn'), helpDlg=byId('helpDlg'), helpClose=byId('helpClose');
const listDlg=byId('listDlg'), listWrap=byId('listWrap'), listClose=byId('listClose');
const cellSlider=byId('cellSlider'), cellPx=byId('cellPx');

const upBtn=byId('upBtn'), downBtn=byId('downBtn'), leftBtn=byId('leftBtn'), rightBtn=byId('rightBtn'), okBtn=byId('okBtn');
const fillBtn=byId('fillBtn'), xBtn=byId('xBtn'), clearBtn=byId('clearBtn');

/* ==================== 状態 ==================== */
let solution = Array.from({length:ROWS},()=>Array(COLS).fill(0));
let rowClues=[], colClues=[];
let player = Array.from({length:ROWS},()=>Array(COLS).fill(0)); // 0空/1黒/2×
let cells=[];
let selR=0, selC=0, prevSelR=0, prevSelC=0;
let currentId = null;

const undoStack=[], redoStack=[];
function snapshot(){return JSON.stringify(player)}
function restore(s){player=JSON.parse(s); redrawAll(); checkAll();}

function pushUndo(before){undoStack.push(before); redoStack.length=0; refreshButtons()}
function doUndo(){
  if(!undoStack.length) return;
  const cur=snapshot(); const prev=undoStack.pop();
  redoStack.push(cur); restore(prev); refreshButtons(); saveLS();
}
function doRedo(){
  if(!redoStack.length) return;
  const cur=snapshot(); const next=redoStack.pop();
  undoStack.push(cur); restore(next); refreshButtons(); saveLS();
}
function refreshButtons(){
  undoBtn.disabled = undoStack.length===0;
  redoBtn.disabled = redoStack.length===0;
}

/* ==================== ヒント生成/描画 ==================== */
function buildClues(){
  rowClues = solution.map(r=>runs(r));
  colClues = Array.from({length:COLS},(_,c)=> runs(solution.map(r=>r[c])));
}
function drawHints(){
  topEl.innerHTML=""; leftEl.innerHTML="";
  colClues.forEach(nums=>{
    const d=document.createElement('div'); d.className='colHint';
    nums.forEach(n=>{const s=document.createElement('div'); s.textContent=n; d.appendChild(s);});
    topEl.appendChild(d);
  });
  rowClues.forEach(nums=>{
    const d=document.createElement('div'); d.className='rowHint';
    nums.forEach(n=>{const s=document.createElement('div'); s.textContent=n; d.appendChild(s);});
    leftEl.appendChild(d);
  });
}

/* ==================== 盤面生成 ==================== */
function buildBoard(){
  boardEl.innerHTML=""; cells=[];
  for(let r=0;r<ROWS;r++){
    cells[r]=[];
    for(let c=0;c<COLS;c++){
      const div=document.createElement('div'); div.className='cell'; div.dataset.r=r; div.dataset.c=c;
      div.addEventListener('mousedown', ()=>boardEl.focus());
      // クリック：開始セルの状態から動作決定（スマホでも同じ）
      div.addEventListener('click', ()=>{
        beginStroke('smart'); const cur=player[r][c];
        const action = (cur===0)? 'fill' : 'clear';
        applyCell(r,c,action); commitStroke();
        setSelected(r,c);
      });
      div.addEventListener('contextmenu',(e)=>{e.preventDefault(); beginStroke('smart'); const cur=player[r][c];
        const action = (cur===0)? 'x' : 'clear'; applyCell(r,c,action); commitStroke(); setSelected(r,c);
      });
      boardEl.appendChild(div);
      cells[r][c]=div;
    }
  }
}

/* ==================== セル描画 & 選択 ==================== */
function updateCell(r,c){
  const el=cells[r][c];
  el.className='cell'; el.dataset.r=r; el.dataset.c=c;
  const v=player[r][c];
  if(v===1){ el.classList.add('filled'); el.textContent=""; }
  else if(v===2){ el.classList.add('xmark'); el.textContent="×"; }
  else el.textContent="";
  if(r===selR && c===selC) el.classList.add('selected');
  if(r===selR) el.classList.add('hiRow');
  if(c===selC) el.classList.add('hiCol');
}
function redrawAll(){ for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) updateCell(r,c); }

function setSelected(r,c){
  cells[selR]?.[selC]?.classList.remove('selected');
  prevSelR=selR; prevSelC=selC; selR=r; selC=c;
  cells[r][c].classList.add('selected');
  updateRowColHL();
  meterEl.textContent = `${selR+1},${selC+1}`;
}
function updateRowColHL(){
  const topHints=[...topEl.children], leftHints=[...leftEl.children];
  leftHints[prevSelR]?.classList.remove('hiHint');
  topHints[prevSelC]?.classList.remove('hiHint');
  leftHints[selR]?.classList.add('hiHint');
  topHints[selC]?.classList.add('hiHint');

  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const el=cells[r][c];
    if(r===selR) el.classList.add('hiRow'); else el.classList.remove('hiRow');
    if(c===selC) el.classList.add('hiCol'); else el.classList.remove('hiCol');
  }
}

/* ==================== ストローク（Undo単位） ==================== */
let strokeActive=false, strokeAction=null, strokeStartedSnapshot=null;
function beginStroke(action){
  if(strokeActive) return;
  strokeActive=true; strokeAction=action; strokeStartedSnapshot=snapshot();
}
function commitStroke(){
  if(!strokeActive) return;
  const before = strokeStartedSnapshot, after=snapshot();
  strokeActive=false; strokeAction=null; strokeStartedSnapshot=null;
  if(before!==after){ pushUndo(before); saveLSDebounced(); }
}

/* ==================== 入力適用 ==================== */
function applyCell(r,c,action){
  const cur=player[r][c];
  if(action==='clear'){ if(cur!==0){ player[r][c]=0; updateCell(r,c); checkAll(); } return; }
  if(action==='fill'){ if(cur===0){ player[r][c]=1; updateCell(r,c); checkAll(); } return; }
  if(action==='x'){    if(cur===0){ player[r][c]=2; updateCell(r,c); checkAll(); } return; }
}

/* ドラッグ */
let dragging=false;
boardEl.addEventListener('pointerdown',(e)=>{
  const t=e.target.closest('.cell'); if(!t) return;
  const r=+t.dataset.r, c=+t.dataset.c; boardEl.setPointerCapture(e.pointerId); dragging=true;
  const cur=player[r][c];
  if(cur===0){
    if(e.button===2){ strokeAction='x'; }
    else if(e.button===0 && e.altKey){ strokeAction='clear'; }
    else{ strokeAction='fill'; }
  }else{ strokeAction='clear'; }
  beginStroke(strokeAction); setSelected(r,c); applyCell(r,c,strokeAction);
});
boardEl.addEventListener('pointermove',(e)=>{
  if(!dragging) return;
  const t=document.elementFromPoint(e.clientX,e.clientY)?.closest('.cell'); if(!t || !boardEl.contains(t)) return;
  const r=+t.dataset.r, c=+t.dataset.c; setSelected(r,c); applyCell(r,c,strokeAction);
});
function endDrag(e){ if(dragging){ dragging=false; commitStroke(); } if(e) boardEl.releasePointerCapture?.(e.pointerId); }
boardEl.addEventListener('pointerup',endDrag);
boardEl.addEventListener('pointercancel',endDrag);
boardEl.addEventListener('contextmenu',e=>e.preventDefault());

/* キーボード */
let holding=false;
boardEl.addEventListener('keydown',e=>{
  if(e.key.startsWith('Arrow')){
    e.preventDefault();
    if(e.key==='ArrowUp') setSelected(Math.max(0,selR-1),selC);
    if(e.key==='ArrowDown') setSelected(Math.min(ROWS-1,selR+1),selC);
    if(e.key==='ArrowLeft') setSelected(selR,Math.max(0,selC-1));
    if(e.key==='ArrowRight') setSelected(selR,Math.min(COLS-1,selC+1));
    if(holding && strokeActive){ applyCell(selR,selC,strokeAction); }
    checkAll(); return;
  }
  if(e.key===' '||e.key==='Enter'){ e.preventDefault();
    if(!holding){ holding=true; strokeAction=(player[selR][selC]===0)?'fill':'clear'; beginStroke(strokeAction); applyCell(selR,selC,strokeAction); }
    return;
  }
  if(e.key.toLowerCase()==='x'){ e.preventDefault();
    if(!holding){ holding=true; strokeAction=(player[selR][selC]===0)?'x':'clear'; beginStroke(strokeAction); applyCell(selR,selC,strokeAction); }
    return;
  }
  if(e.key.toLowerCase()==='c'){ e.preventDefault();
    if(!holding){ holding=true; strokeAction='clear'; beginStroke(strokeAction); applyCell(selR,selC,strokeAction); }
    return;
  }
  if(e.key==='Delete'||e.key==='Backspace'){ e.preventDefault(); beginStroke('clear'); applyCell(selR,selC,'clear'); commitStroke(); return; }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); doUndo(); return; }
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='y'){ e.preventDefault(); doRedo(); return; }
  if(e.key==='Escape'){ if(holding){ holding=false; commitStroke(); } return; }
});
window.addEventListener('keyup',e=>{
  if((e.key===' '||e.key==='Enter'||e.key.toLowerCase()==='x'||e.key.toLowerCase()==='c') && holding){
    holding=false; commitStroke();
  }
});

/* D-Pad 長押しオートリピート */
function withRepeat(el, onFire){
  let timer=null, rep=null;
  const fire=()=>onFire();
  el.addEventListener('pointerdown', e=>{
    e.preventDefault(); fire();
    timer=setTimeout(()=>{ rep=setInterval(fire, REPEAT_STEP); }, REPEAT_DELAY);
  });
  const stop=()=>{
    clearTimeout(timer); timer=null; clearInterval(rep); rep=null;
    commitStroke();
  };
  el.addEventListener('pointerup',stop);
  el.addEventListener('pointercancel',stop);
  el.addEventListener('pointerleave',stop);
}
withRepeat(upBtn,   ()=>{ setSelected(Math.max(0,selR-1),selC); if(holding && strokeActive){ applyCell(selR,selC,strokeAction);} });
withRepeat(downBtn, ()=>{ setSelected(Math.min(ROWS-1,selR+1),selC); if(holding && strokeActive){ applyCell(selR,selC,strokeAction);} });
withRepeat(leftBtn, ()=>{ setSelected(selR,Math.max(0,selC-1)); if(holding && strokeActive){ applyCell(selR,selC,strokeAction);} });
withRepeat(rightBtn,()=>{ setSelected(selR,Math.min(COLS-1,selC+1)); if(holding && strokeActive){ applyCell(selR,selC,strokeAction);} });
okBtn.addEventListener('click', ()=>{ beginStroke('smart'); const cur=player[selR][selC]; const act=(cur===0)?'fill':'clear'; applyCell(selR,selC,act); commitStroke(); });

withRepeat(fillBtn,  ()=>{ holding=true; strokeAction=(player[selR][selC]===0)?'fill':'clear'; if(!strokeActive) beginStroke(strokeAction); applyCell(selR,selC,strokeAction); });
withRepeat(xBtn,     ()=>{ holding=true; strokeAction=(player[selR][selC]===0)?'x':'clear';    if(!strokeActive) beginStroke(strokeAction); applyCell(selR,selC,strokeAction); });
withRepeat(clearBtn, ()=>{ holding=true; strokeAction='clear';                                if(!strokeActive) beginStroke(strokeAction); applyCell(selR,selC,strokeAction); });

/* ==================== エラー/達成チェック ==================== */
function getLineValues(isRow, idx){
  const arr=[]; if(isRow){ for(let c=0;c<COLS;c++) arr.push(player[idx][c]); } else { for(let r=0;r<ROWS;r++) arr.push(player[r][idx]); }
  return arr;
}
function countOnes(arr){let n=0; for(const v of arr) if(v===1) n++; return n;}
function getSegments(arr){const segs=[]; let s=-1; for(let i=0;i<arr.length;i++){ if(arr[i]!==2 && s<0) s=i; if((arr[i]===2 || i===arr.length-1) && s>=0){ const e=(arr[i]===2)?i-1:i; segs.push([s,e]); s=-1; } } return segs;}
function segLen(seg){return seg[1]-seg[0]+1}

function clearHintState(el){ el.classList.remove('hintError'); [...el.children].forEach(n=> n.classList.remove('error','done')); }

function getPossibleRanges(hints, vals) {
    const numHints = hints.length;
    const lineLen = vals.length;
    if (numHints === 0 || (numHints === 1 && hints[0] === 0)) {
        return { L: [], Rend: [] };
    }

    const L = new Array(numHints); // 左詰め開始位置
    const R = new Array(numHints); // 右詰め開始位置

    // --- L (左詰め) の計算 ---
    let currentPosL = 0;
    for (let i = 0; i < numHints; i++) {
        const hintLen = hints[i];
        if (i > 0) {
            // 前のヒントの終了位置 + ギャップ
            currentPosL = L[i - 1] + hints[i - 1] + 1;
        }
        
        while (true) {
            const endPos = currentPosL + hintLen - 1;
            if (endPos >= lineLen) { L[i] = lineLen; break; } // 配置不可
            
            let hasX = false;
            for (let k = currentPosL; k <= endPos; k++) {
                if (vals[k] === 2) { hasX = true; currentPosL = k + 1; break; }
            }
            if (!hasX) { L[i] = currentPosL; break; }
        }
    }

    // --- R (右詰め) の計算 ---
    let currentPosR = lineLen - 1;
    for (let i = numHints - 1; i >= 0; i--) {
        const hintLen = hints[i];
        if (i < numHints - 1) {
            // 次のヒントの開始位置 - ギャップ
            currentPosR = R[i + 1] - 1 - 1;
        }

        while (true) {
            const startPos = currentPosR - hintLen + 1;
            if (startPos < 0) { R[i] = -1; break; } // 配置不可

            let hasX = false;
            for (let k = startPos; k <= currentPosR; k++) {
                if (vals[k] === 2) { hasX = true; currentPosR = k - 1; break; }
            }
            if (!hasX) { R[i] = startPos; break; }
        }
    }
    
    const Rend = R.map((start, i) => (start === -1) ? -1 : start + hints[i] - 1);
    return { L, Rend };
}

function evalLine(isRow, idx, hints, hintEl){
  clearHintState(hintEl);
  const vals=getLineValues(isRow,idx);
  const onesRuns=runs(vals.map(v=>v===1));
  const onesCount=countOnes(vals);
  const segs=getSegments(vals);
  const hintSum=sum(hints), hintMax=maxv(hints);

  const done = JSON.stringify(onesRuns)===JSON.stringify(hints);
  if(done){ [...hintEl.children].forEach(n=> n.classList.add('done')); }

  let lineError=false;
  const perHintError=new Array(hints.length).fill(false);

  /* 塊数過剰は「Xで分断された確定黒ブロック数」で判定（未確定0では分断扱いしない） */
  const groupsByX = segs.filter(([s,e])=>{
    for(let i=s;i<=e;i++){ if(vals[i]===1) return true; }
    return false;
  }).length;
  if(groupsByX > hints.length) lineError = true;

  /* 合計超過／連続長超過（確定矛盾） */
  if(onesCount>hintSum) lineError=true;
  if(maxv(onesRuns)>hintMax) lineError=true;

  /* 置場消滅（そのヒント数字だけ赤） */
  for(let i=0;i<hints.length;i++){
    const h=hints[i]; let can=false; for(const seg of segs){ if(segLen(seg)>=h){ can=true; break; } }
    if(!can) perHintError[i]=true;
  }

  if(lineError){ hintEl.classList.add('hintError'); }
  else{ [...hintEl.children].forEach((n,i)=>{ if(perHintError[i]) n.classList.add('error'); }); }

  if(!lineError && done){ [...hintEl.children].forEach(n=>{ n.classList.remove('error'); n.classList.add('done'); }); }

  /* ===== 追加：数字ごとの「部分確定」判定 ===== */
  if(!lineError && !done){
    const hintChildren=[...hintEl.children];
    const used = new Array(hints.length).fill(false);

    // 1. ヒントの取りうる配置範囲を計算
    const { L, Rend } = getPossibleRanges(hints, vals);

    // 2. 確定した黒ブロックを抽出
    const blackBlocks=[];
    for(let i=0;i<vals.length;i++){
      if(vals[i]===1){
        let j=i; while(j+1<vals.length && vals[j+1]===1) j++;
        blackBlocks.push([i,j]); i=j;
      }
    }

    // ヘルパー関数
    const noZeroInRange=(a,b)=>{ if(a>b) return true; for(let k=a;k<=b;k++){ if(vals[k]===0) return false; } return true; };
    const prevWall=(pos)=>{ for(let k=pos;k>=0;k--){ if(vals[k]===2) return k; } return -1; };
    const nextWall=(pos)=>{ for(let k=pos;k<vals.length;k++){ if(vals[k]===2) return k; } return vals.length; };

    // 3. 確定ブロックをヒントに割り当て
    for(const [s,e] of blackBlocks){
      const p = prevWall(s-1);
      const q = nextWall(e+1);

      // 壁から黒ブロックまでの「内側」の区間がすべて埋まっているか
      const innerLeftFilled  = noZeroInRange(p + 1, s - 1);
      const innerRightFilled = noZeroInRange(e + 1, q - 1);

      // 壁の「外側」が確定しているか（盤の端まで0がないか）
      const outerLeftFixed = (p === -1) ? true : noZeroInRange(0, p - 1);
      const outerRightFixed = (q === vals.length) ? true : noZeroInRange(q + 1, vals.length - 1);

      // ブロックの左右がそれぞれ確定しているか（内側と外側の両方が埋まっている必要がある）
      const isLeftFixed = innerLeftFilled && outerLeftFixed;
      const isRightFixed = innerRightFilled && outerRightFixed;

      // ブロック全体が確定しているのは、左右両方が確定している場合のみ
      if(!(isLeftFixed && isRightFixed)) continue;

      const len = e - s + 1;

      // この確定ブロックに合致する未使用ヒントを探す
      for(let hIdx=0; hIdx<hints.length; hIdx++){
        if(used[hIdx]) continue;
        // 長さ一致 ＆ 位置整合性チェック
        if(hints[hIdx] === len && s >= L[hIdx] && e <= Rend[hIdx]){
          used[hIdx]=true;
          hintChildren[hIdx]?.classList.add('done');
          break; // このブロックの割り当ては完了
        }
      }
    }
  }
}

function checkClues(){
  const leftHints=[...leftEl.children], topHints=[...topEl.children];
  for(let r=0;r<ROWS;r++) evalLine(true, r, rowClues[r], leftHints[r]);
  for(let c=0;c<COLS;c++) evalLine(false, c, colClues[c], topHints[c]);
}

let celebrated=false;
function triggerCelebrate(){
  boardEl.classList.add('celebrate'); setTimeout(()=>boardEl.classList.remove('celebrate'), 900);
  const pops=[]; let delay=0;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(solution[r][c]===1){ const el=cells[r][c]; el.classList.add('pop'); el.style.animationDelay=`${delay}ms`; pops.push(el); delay+=12; }
  }
  setTimeout(()=>{ pops.forEach(el=>{ el.classList.remove('pop'); el.style.animationDelay=""; }); }, delay+400);
}

function checkSolved(){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if((solution[r][c]===1)!==(player[r][c]===1)){ progressEl.textContent=getProgressText(); return; }
  }
  progressEl.textContent="クリア！";
  if(!celebrated){ celebrated=true; triggerCelebrate(); }
}
function checkAll(){ checkClues(); checkSolved(); progressEl.textContent=getProgressText(); }

function getProgressText(){
  let correct=0,total=ROWS*COLS;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const need=solution[r][c]===1, put=player[r][c]===1;
    if(need===put) correct++;
  }
  const pct=Math.round((correct/total)*100);
  return `一致率: ${pct}%`;
}

/* ==================== パズル切替 & 保存 ==================== */
function loadPuzzleById(id){
  const p = PUZZLES.find(x=>x.id===id) || PUZZLES[0];
  currentId=p.id;
  solution = strToGrid(p.art);
  buildClues(); drawHints(); buildBoard();
  if(loadLS()){ /* loaded */ } else { player=Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
  redrawAll(); setSelected(0,0); checkAll();
  celebrated=false; progressEl.textContent=getProgressText(); saveLS(); localStorage.setItem(LS_LAST_ID,currentId);
}
function randomPuzzle(){
  const idx = Math.floor(Math.random()*PUZZLES.length);
  loadPuzzleById(PUZZLES[idx].id);
}

function saveLS(){ try{ localStorage.setItem(`picross-20x20-${currentId}`, snapshot()); }catch{} }
let saveTimer=null;
function saveLSDebounced(){ clearTimeout(saveTimer); saveTimer=setTimeout(saveLS,300); }
function loadLS(){
  try{
    const s=localStorage.getItem(`picross-20x20-${currentId}`);
    if(!s) return false; const state=JSON.parse(s);
    if(Array.isArray(state) && state.length===ROWS){ player=state; return true; }
  }catch{}
  return false;
}

/* ==================== UIイベント ==================== */
undoBtn.onclick=()=>doUndo();
redoBtn.onclick=()=>doRedo();
resetBtn.onclick=()=>{
  beginStroke('clear-all'); for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ if(player[r][c]!==0){ player[r][c]=0; updateCell(r,c); } }
  commitStroke(); celebrated=false; checkAll(); saveLS();
};
checkBtn.onclick=()=>{ progressEl.textContent=getProgressText(); };
newBtn.onclick=()=>{ loadPuzzleById(currentId); };
randBtn.onclick=()=>{ randomPuzzle(); };
helpBtn.onclick=()=> helpDlg.showModal();
byId('helpClose').onclick=()=> helpDlg.close();

/* 一覧 */
listBtn.onclick=()=>{
  listWrap.innerHTML="";
  for(const p of PUZZLES){
    const card=document.createElement('div'); card.className='card';
    const h=document.createElement('h4'); h.textContent=p.title; card.appendChild(h);
    const small=document.createElement('div'); small.style.fontSize=".8rem"; small.style.color="#555"; small.textContent=p.id; card.appendChild(small);
    const btn=document.createElement('button'); btn.className='btn'; btn.textContent='このパズルを開く';
    btn.onclick=()=>{ listDlg.close(); loadPuzzleById(p.id); };
    card.appendChild(btn);
    listWrap.appendChild(card);
  }
  listDlg.showModal();
};
listClose.onclick = ()=> listDlg.close();

/* セルサイズ（手動スライダ） */
function applyCellSize(px){ document.documentElement.style.setProperty('--cell', px+'px'); cellPx.textContent=px+'px'; }
(function initCellSize(){
  const saved=parseInt(localStorage.getItem(LS_CELL_KEY)||"",10);
  const init=Number.isFinite(saved)? clamp(saved,24,46) : 32;
  cellSlider.value=String(init); applyCellSize(init);
})();
let sizeTimer=null;
cellSlider.addEventListener('input', ()=>{
  // 手動操作は尊重（初期表示の「全体が見える」要件はクリア済み）
  applyCellSize(parseInt(cellSlider.value,10));
  byId('tooSmall').style.display='none'; // 手動サイズ変更時はオーバーレイを閉じる
  clearTimeout(sizeTimer); sizeTimer=setTimeout(()=>{ try{ localStorage.setItem(LS_CELL_KEY, cellSlider.value);}catch{} }, 200);
});

/* ==================== 初期表示：自動フィット実装 ==================== */
function getAvailableSize(){
  const topH = document.querySelector('.topbar')?.offsetHeight || 0;
  const ctlH = document.querySelector('.control')?.offsetHeight || 0;
  const width  = Math.max(0, window.innerWidth  - SAFETY_W);
  const height = Math.max(0, window.innerHeight - (topH + ctlH + SAFETY_H));
  return {width, height};
}

function fitsAt(px){
  applyCellSize(px); // CSS変数を即時反映
  const wrap = document.querySelector('.wrap');
  if(!wrap) return false;
  const rect = wrap.getBoundingClientRect();
  const avail = getAvailableSize();
  return rect.width <= avail.width && rect.height <= avail.height;
}

function fitInitialView(){
  const overlay = byId('tooSmall');
  let chosen = null;
  // 大きい方から試して、収まる最大pxを採用
  for(let px=MAX_CELL; px>=MIN_CELL; px-=STEP_CELL){
    if(fitsAt(px)){ chosen = px; break; }
  }
  if(chosen !== null){
    overlay.style.display='none';
    applyCellSize(chosen);
    // スライダー・LSにも反映（次回起動時の初期値として使う）
    cellSlider.value = String(chosen);
    try{ localStorage.setItem(LS_CELL_KEY, String(chosen)); }catch{}
  }else{
    // どのサイズでも収まらない → プレイ不可の表示
    overlay.style.display='flex';
  }
}

/* ==================== 起動 ==================== */
(async function boot(){
  try{
    await loadPuzzles();
  }catch(e){
    alert(e.message || 'パズルデータの読み込みに失敗しました');
    return;
  }

  const last=localStorage.getItem(LS_LAST_ID);
  loadPuzzleById(last || PUZZLES[0].id);
  setSelected(0,0); boardEl.focus();

  // 初期表示：盤面＋行列ヒントが必ず見えるよう自動フィット
  requestAnimationFrame(()=>fitInitialView());

  setInterval(refreshButtons, 400);
})();

</script>
</body>
</html>
